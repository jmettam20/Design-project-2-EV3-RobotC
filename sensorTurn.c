#pragma config(Sensor, S2,     gyroSenso,      sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorNone)
#pragma config(Sensor, S4,     sonarSensor,    sensorNone)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------------------------------------------------
This program will turn the robot 90 dgrees to the left. At the end of the program, all motors
will shut down automatically and turn off.

ROBOT CONFIGURATION: LEGO EV3 REM Bot
MOTORS & SENSORS:
[I/O Port]          [Name]              [Type]                			[Location]
MotorC        			leftMotor           LEGO EV3 Motor		      Left side motor
MotorB       				rightMotor          LEGO EV3 Motor		      Right side motor (reversed)
------------------------------------------------------------------------------------------------*/

void sensorTurn(signed int degIn, int speed);

task main()
{
	//while(1)//stop
	{
		sensorTurn(-90,25);//sensor fusion turn function
	}

}

void sensorTurn (signed int degIn, int speed)
{
	/*
	degIn must be positive for left or negative for right, a zero value defaults to left
	speed goes from 0 to 256 although a speed of 0 will do nothing
	function flow is like this;
	convert degrees to encoder ticks -> reset sensors -> check if shoud be turning left or right ->
	select correct motor encoder to use -> give all values to setMotorSyncEncoder()->
	move motors until values are satisfied-> exit the loop -> stop both motors.
	*/
	int tickVal = (degIn/90)*195;  //convert degrees of turn to ticks in the encoder
	resetGyro(S2);//reset data for gyro to read
	resetMotorEncoder(leftMotor);//reset motor encoders
	resetMotorEncoder(rightMotor);
	int degVal  = getGyroDegrees(S2);//give an intial value that works with the while loop to jump into it
	int dirVal;
	if (degIn >= 0)//left
	{
		int motVal = getMotorEncoder(rightMotor);
		dirVal = 100;
		setMotorSyncEncoder(leftMotor, rightMotor, dirVal, tickVal, speed);// set rotation direction and amount. 195 is 90 degrees, 100 is left, -100 i right
		while(((degVal > (degIn + 2)) || (degVal < degIn - 2)) && ( motVal < tickVal))
		{
			/* while loop uses a range of permitted values from the gyro an waits until both the gyro and th motor roughly agree with agree*/
			degVal = getGyroDegrees(S2);//check values insdie the loop
			motVal = getMotorEncoder(rightMotor);
		}
	}
	else if (degIn < 0 )//right
	{
		int motVal = getMotorEncoder(leftMotor);
		dirVal = -100;
		setMotorSyncEncoder(leftMotor, rightMotor, dirVal, -tickVal, speed);// set rotation direction and amount. 195 is 90 degrees, 100 is left, -100 i right
		while(((degVal > (degIn -23)) || (degVal < degIn - 18)) && ( motVal < -tickVal))
		{
			/* while loop uses a range of permitted values from the gyro an waits until both the gyro and th motor roughly agree with agree*/
			degVal = getGyroDegrees(S2);//check values insdie the loop
			motVal = getMotorEncoder(rightMotor);
		}
	}
	eraseDisplay();
	int screenPrint = getGyroDegrees(S2);
	displayTextLine(2,"degrees: %d",screenPrint);


	//once the while loop finihes the next instruction is read and setMotorSyncEncoder() is off, stopping the motors.
}
