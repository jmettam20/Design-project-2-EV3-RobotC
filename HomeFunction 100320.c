#pragma config(Sensor, S1,     ultrasonicSensor, sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colourSensorBottom, sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Medium, openLoop)
#pragma config(Motor,  motorC,          armMotor,      tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

volatile int gyro;

volatile int colour;

task gyroValue()
{
	while(1){
		gyro = getGyroDegrees(gyroSensor);
	}
}

task colourValue()
{ while(1){
		colour = getColorName(colourSensorBottom);
	}
}

void turnTarget(bool direction,int degrees)
{
	resetGyro(gyroSensor);
	wait1Msec(5);
if (direction == 0)
	{//left
	int gyroTarget = -degrees;
	while(gyro >= gyroTarget)
	{//turn
		setMotorSpeed(leftMotor, -25);
		setMotorSpeed(rightMotor, 25);
		displayBigTextLine(3, "%d", gyro);
	}
	//stop
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	if (direction == 1){//right
	int gyroTarget = degrees;
	while(gyro >= gyroTarget)
	{//turn
		setMotorSpeed(leftMotor, 25);
		setMotorSpeed(rightMotor, -25);
		displayBigTextLine(3, "%d", gyro);
	}
	//stop
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	}
}
}

void home()
{
	resetMotorEncoder(leftMotor);//give 0 start val
	int edge = colour;
	while(edge != 5)//jump in to loop
	{
		edge = colour;
		displayBigTextLine(5, "%d", colour);
		setMotorSync(leftMotor, rightMotor, 0, 25);//move forward
	}
	//jump out of loop
	resetMotorEncoder(leftMotor);//reset measurement
	setMotorSync(leftMotor,rightMotor, 0 , -25);//move backwards
	wait1Msec(700);//get off the line
	//jump in to loop
	edge = colour;
	while(edge != 5)
	{
		edge = colour;
		setMotorSync(leftMotor,rightMotor, 0, -25);//move backwards
	}
	//jump out of loop
	setMotorSpeed(leftMotor, 0);//stop
	setMotorSpeed(rightMotor,0);
	int distanceBack = fabs(getMotorEncoder(leftMotor));//calculate distance moved back
	resetMotorEncoder(leftMotor);//reset measurement
	int distanceTot = distanceBack;//total distance moved
	setMotorSyncEncoder(leftMotor,rightMotor,0,(distanceTot/2), 25);//move forward half total
	waitUntilMotorStop(leftMotor);//wait
  turnTarget(0,90);
	resetMotorEncoder(leftMotor);
	//right edge
	edge = colour;
	while(edge != 5)
	{
		edge = colour;
		setMotorSync(leftMotor, rightMotor, 0, 25);
	}
	//save distance
	resetMotorEncoder(leftMotor);//go back
	setMotorSync(leftMotor,rightMotor, 0 , -25);
	wait1Msec(700);//get off line
	//wait for line detection
	edge = colour;
	while(edge != 5)
	{
		edge = colour;
		setMotorSync(leftMotor,rightMotor, 0, -25);
	}
	//stop
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor,0);
	distanceBack = fabs(getMotorEncoder(leftMotor));//save distance travelled
	resetMotorEncoder(leftMotor);//reset
	int distanceWidth = fabs(distanceBack);//find total width
	setMotorSyncEncoder(leftMotor,rightMotor,0,(distanceWidth/2), 25);//move forward half total width
	waitUntilMotorStop(leftMotor);//wait
 turnTarget(1,90);
}

task main()
{
	startTask (gyroValue);
	startTask (colourValue);
	home();

}
